<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/suite_openpgp.js | Cascade</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="Cryptographic Library"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="Cascade"><meta property="twitter:description" content="Cryptographic Library"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  <a href="test.html" data-ice="testLink">Test</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/junkurihara/cascade"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/cascaded_data.js~CascadedData.html">CascadedData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/encrypted_message.js~EncryptedMessage.html">EncryptedMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/encrypted_message.js~RawEncryptedMessage.html">RawEncryptedMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/encrypted_message.js~RawEncryptedMessageList.html">RawEncryptedMessageList</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/keyid.js~KeyId.html">KeyId</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/keyid.js~KeyIdList.html">KeyIdList</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/keys.js~Keys.html">Keys</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/signature.js~RawSignature.html">RawSignature</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/signature.js~Signature.html">Signature</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/suite.js~Suite.html">Suite</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/suite_jscu.js~Jscu.html">Jscu</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/suite_openpgp.js~OpenPGP.html">OpenPGP</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createDecryptionCascade">createDecryptionCascade</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createEncryptionCascade">createEncryptionCascade</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createCascadedData">createCascadedData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-importCascadedBuffer">importCascadedBuffer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-decrypt">decrypt</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-encrypt">encrypt</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-generateKey">generateKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-sign">sign</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-verify">verify</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createEncryptedMessage">createEncryptedMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createRawEncryptedMessage">createRawEncryptedMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-importEncryptedBuffer">importEncryptedBuffer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-importRawEncryptedBufferList">importRawEncryptedBufferList</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createKeyId">createKeyId</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createKeyIdList">createKeyIdList</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-fromJscuKey">fromJscuKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-fromOpenPgpKey">fromOpenPgpKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-fromRawKey">fromRawKey</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-generateKeyObject">generateKeyObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-importKeys">importKeys</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-importMessage">importMessage</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createRawSignature">createRawSignature</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-createSignature">createSignature</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-importSignatureBuffer">importSignatureBuffer</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getJscu">getJscu</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-getOpenPgp">getOpenPgp</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/suite_openpgp.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">/**
 * suite_openpgp.js
 */
import jseu from &apos;js-encoding-utils&apos;;
import {getOpenPgp} from &apos;./util.js&apos;;
import {Suite} from &apos;./suite.js&apos;;
import config from &apos;./config.js&apos;;
import * as utilKeyId from &apos;./keyid.js&apos;;
import {createRawSignature, createSignature, RawSignature} from &apos;./signature.js&apos;;
import {createEncryptedMessage, createRawEncryptedMessage} from &apos;./encrypted_message.js&apos;;


// mapping names of curve
const curveList = {
  &apos;P-256&apos;: {name: &apos;p256&apos;},
  &apos;P-384&apos;: {name: &apos;p384&apos;},
  &apos;P-521&apos;: {name: &apos;p521&apos;}
};

export class OpenPGP extends Suite {

  /**
   * Generated OpenPGP Key Object with given key params.
   * @param userIds {Array}
   * @param passphrase {string}
   * @param params {Object}
   * @return {Promise&lt;*&gt;}
   */
  static async generateKey({userIds=config.openpgp.defaultUser, passphrase=null, params}) {
    const openpgp = getOpenPgp();

    let options;
    switch (params.type) {
    case &apos;rsa&apos;:
      options = {
        userIds,       // multiple user IDs
        numBits: params.modulusLength,// RSA key size
        passphrase,  // protects the private key
        keyExpirationTime: params.keyExpirationTime
      };
      break;
    case &apos;ec&apos;:
      options = {
        userIds,       // multiple user IDs
        curve: curveList[params.curve].name,  // applied the naming rule of jscu
        passphrase,  // protects the private key
        keyExpirationTime: params.keyExpirationTime
      };
      break;
    case &apos;session&apos;:
      options = {
        length: params.length
      };
      break;
    default:
      throw new Error(&apos;GPGUnsupportedAlgorithm&apos;);
    }

    if (params.type === &apos;rsa&apos; || params.type === &apos;ec&apos;) {
      const kp = await openpgp.generateKey(options);
      let keyId = kp.key.getKeys().map((k) =&gt; utilKeyId.fromOpenPgpKey(k));
      if (keyId.length === 1) keyId = keyId[0];

      return {
        publicKey: kp.key.toPublic(),
        privateKey: kp.key,
        keyId  //kp.key.getKeyIds().map( (bid) =&gt; bid.toHex())
      };
    }
    else if (params.type === &apos;session&apos;) {
      const rawKey = await openpgp.crypto.random.getRandomBytes(options.length);
      const keyId = await utilKeyId.fromRawKey(rawKey);
      return {key: rawKey, keyId};
    }
  }

  static async importKey(type, key, passphrase){
    const openpgp = getOpenPgp();

    const read = (type === &apos;pem&apos;)
      ? await openpgp.key.readArmored(key)
      : await openpgp.key.read(key);

    if(read.err) throw new Error(`InvalidOpenPGPKeyFormat: ${read.err}`);

    const keyArray = await Promise.all(read.keys.map(async (keyObject) =&gt; {
      if (keyObject.isPrivate() &amp;&amp; keyObject.primaryKey.isEncrypted) {
        await keyObject.decrypt(passphrase);
      }
      return keyObject;
    }));

    return (keyArray.length &gt; 1) ? keyArray : keyArray[0];
  }

  /**
   * returns {message: { Message, suite }, signature: { Signature, suite }}
   * if encryption is done simultaneously with signing, no signature id is given because of privacy reason (issuer hiding)
   * @param message
   * @param keys
   * @param options
   * @param output
   * @return {Promise&lt;*&gt;}
   */
  static async encrypt({message, keys, options={}}){
    const openpgp = getOpenPgp();

    // check options
    if(options.compression) options.compression = openpgp.enums.compression[options.compression];
    options.armor = false; // armor must be false to get key ids after encryption.

    // convert message
    const msgObj = openpgp.message.fromBinary(message.binary);

    // check signing key format to do signing simultaneously with encryption
    let signingKeys;
    if(typeof keys.privateKeys !== &apos;undefined&apos;
      &amp;&amp; keys.privateKeys instanceof Array
      &amp;&amp; keys.privateKeys[0] instanceof openpgp.key.Key) signingKeys = keys.privateKeys;

    // encryption
    let encrypted;
    let encryptedObject;
    if(keys.publicKeys){ // public key encryption
      const opt = {
        message: msgObj,
        publicKeys: keys.publicKeys, // for encryption
        privateKeys: signingKeys, // for signing (optional)
        format: &apos;binary&apos;
      };
      encrypted = await openpgp.encrypt(Object.assign(opt, options));

      // construct an encrypted message object
      const internalHexKeyIds = encrypted.message.getEncryptionKeyIds().map( (id) =&gt; id.toHex());
      const externalKeyIds = [];
      keys.publicKeys.map( (x) =&gt; x.getKeys().map( (k) =&gt; { externalKeyIds.push(utilKeyId.fromOpenPgpKey(k));} ) );
      const encryptionKeyId = externalKeyIds.filter( (fp) =&gt; internalHexKeyIds.indexOf(fp.toHex().slice(0, 16)) &gt;= 0);
      const encryptedMessage = [
        createRawEncryptedMessage(encrypted.message.packets.write(), utilKeyId.createKeyIdList(encryptionKeyId), {})
      ];
      encryptedObject = {message: createEncryptedMessage(&apos;openpgp&apos;, &apos;public_key_encrypt&apos;, encryptedMessage, {})};
    }
    else if (keys.sessionKey) { // symmetric key encryption
      const opt = {
        message: msgObj,
        sessionKey: {data: keys.sessionKey, algorithm: options.algorithm}, // for encryption
        privateKeys: signingKeys, // for signing (optional)
        format: &apos;binary&apos;
      };
      encrypted = await openpgp.encrypt(Object.assign(opt, options));

      // construct an encrypted message object
      const encryptedMessage = [
        createRawEncryptedMessage(encrypted.message.packets.write(), await utilKeyId.fromRawKey(keys.sessionKey), {})
      ];
      encryptedObject = {message: createEncryptedMessage(
        &apos;openpgp&apos;, &apos;session_key_encrypt&apos;, encryptedMessage, {algorithm: options.algorithm}
      )};
    }
    else throw new Error(&apos;InvalidEncryptionKey&apos;);

    let signatureObj = {};
    if (keys.privateKeys &amp;&amp; encrypted.signature) { // if detached is true
      const signatureObjectList = OpenPGP._listFromOpenPgpSig(encrypted.signature.packets, signingKeys);
      signatureObj = {signature: createSignature(&apos;openpgp&apos;, &apos;public_key_sign&apos;, signatureObjectList, {})};
    }

    return Object.assign(encryptedObject, signatureObj);
  }


  /**
   * Decrypt OpenPGP encrypted message
   * @param encrypted
   * @param keys
   * @param options
   * @return {Promise&lt;*&gt;}
   */
  static async decrypt({ encrypted, keys, options = {} }){
    const openpgp = getOpenPgp();

    const message = await openpgp.message.read(encrypted.message.message[0].toBuffer(), false);
    const params = Object.assign({ message, publicKeys: keys.publicKeys, format: &apos;binary&apos; }, options);

    if(encrypted.message.keyType === &apos;public_key_encrypt&apos;){
      Object.assign(params, {privateKeys: keys.privateKeys});
    }
    else if (encrypted.message.keyType === &apos;session_key_encrypt&apos;){
      Object.assign(params, {sessionKeys: [ {data: keys.sessionKey, algorithm: options.algorithm} ]});
    }
    else throw new Error(&apos;UnknownKeyType&apos;);

    const decrypted = await openpgp.decrypt(params);
    decrypted.data = new Uint8Array(decrypted.data);

    if (decrypted.signatures instanceof Array){
      decrypted.signatures = decrypted.signatures.map( (sig) =&gt; {
        const short = sig.keyid.toHex();
        const long = sig.signature.packets.map( (s) =&gt; new Uint8Array(s.issuerFingerprint));
        const filtered = long.filter((l) =&gt; short === jseu.encoder.arrayBufferToHexString(l).slice(0, 16) );
        if (filtered.length === 0) throw new Error(&apos;SomethingWrongInOpenPGPSignature&apos;);
        return {keyId: utilKeyId.createKeyId(filtered[0]), valid: sig.valid};
      });
    }

    return decrypted;
  }

  /**
   * Returns detached signature
   * @param message
   * @param keys
   * @param options
   * @param output
   * @return {Promise&lt;*&gt;}
   */
  static async sign({message, keys, options={}}){
    const openpgp = getOpenPgp();

    // check options
    options.detached = true; // this must be always true for individual signature
    options.armor = false; // this must be always false to get key ids

    const msgObj = openpgp.message.fromBinary(message.binary);

    if(!keys.privateKeys) throw new Error(&apos;SigningKeyRequired&apos;);
    const opt = {
      message: msgObj,
      privateKeys: keys.privateKeys // for signing (optional)
    };
    const signature = await openpgp.sign(Object.assign(opt, options));
    const signatureObjectList = OpenPGP._listFromOpenPgpSig(signature.signature.packets, keys.privateKeys);
    return {signature: createSignature(&apos;openpgp&apos;, &apos;public_key_sign&apos;, signatureObjectList, {})};
  }

  /**
   * Returns detached signature with verification result
   * @param message
   * @param signature
   * @param keys
   * @param options
   * @return {Promise&lt;*&gt;}
   */
  static async verify({message, signature, keys, options}){
    const openpgp = getOpenPgp();

    if(!keys.publicKeys) throw new Error(&apos;VerificationKeyRequired&apos;);
    const list = OpenPGP._ListToOpenPgpSig(signature.signatures, keys.publicKeys);
    const msgObj = openpgp.message.fromBinary(message.binary);

    const verified = await Promise.all(list.signatureObjects.map( async (sigKey) =&gt; {
      const msg = msgObj.unwrapCompressed();
      const literalDataList = msg.packets.filterByTag(openpgp.enums.packet.literal);
      const signatureList = [sigKey.openpgpSignature];
      const valid = await openpgp.message.createVerificationObjects(signatureList, literalDataList, [sigKey.publicKey], new Date());
      return {keyId: sigKey.signature.keyId, valid: await valid[0].verified};
    }));

    return verified.concat(list.unverified);
  }

  static _listFromOpenPgpSig (signatures, keys) {
    if (!(signatures instanceof Array)) throw new Error(&apos;InvalidSignatureList&apos;);

    const externalKeyIds = [];
    keys.map( (x) =&gt; x.getKeys().map( (k) =&gt; { externalKeyIds.push(utilKeyId.fromOpenPgpKey(k));} ) );

    const signatureObjects = [];
    externalKeyIds.map( (fp) =&gt; {
      const correspondingSig = signatures.filter( (sig) =&gt; sig.issuerKeyId.toHex() === fp.toHex().slice(0,16));
      correspondingSig.map((sig) =&gt; {
        signatureObjects.push(createRawSignature(sig.write(), fp));
      });
    });

    return signatureObjects;
  }

  static _ListToOpenPgpSig (signatures, keys) {
    if (!(signatures instanceof Array)) throw new Error(&apos;InvalidSignatureList&apos;);

    const openpgp = getOpenPgp();

    const openpgpObjects = signatures.map((sig) =&gt; {
      if (!(sig instanceof RawSignature)) throw new Error(&apos;NotRawSignatureObject&apos;);
      const obj = new openpgp.packet.Signature();
      obj.read(sig.toBuffer(), 0, -1);
      return {openpgpSignature: obj, signature: sig};
    });

    const externalKey = [];
    keys.map( (x) =&gt; x.getKeys().map( (k) =&gt; { externalKey.push({publicKey: k, keyId: utilKeyId.fromOpenPgpKey(k)});} ) );

    const signatureObjects = [];
    externalKey.map( (fp) =&gt; {
      const correspondingSig = openpgpObjects.filter( (sig) =&gt; sig.openpgpSignature.issuerKeyId.toHex() === fp.keyId.toHex().slice(0,16));
      correspondingSig.map((sig) =&gt; {
        signatureObjects.push(Object.assign({publicKey: fp.publicKey}, sig));
      });
    });
    const unverified = [];
    const idArray = signatureObjects.map( (x) =&gt; x.openpgpSignature.issuerKeyId.toHex());
    openpgpObjects.map( (sig) =&gt; {
      if(idArray.indexOf(sig.openpgpSignature.issuerKeyId.toHex().slice(0,16)) &lt; 0){
        unverified.push({keyId: utilKeyId.createKeyId(sig.openpgpSignature.issuerFingerprint), valid: undefined});
      }
    });

    return {signatureObjects, unverified};
  }
}</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
